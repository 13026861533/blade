<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blade,简洁强大的javaweb框架">
    <meta name="author" content="biezhi">
	<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <title>Blade - 简洁强大的javaweb框架</title>
    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
	<link href="../css/roboto.min.css" rel="stylesheet">
    <link href="../css/material.min.css" rel="stylesheet">
    <link href="../css/ripples.min.css" rel="stylesheet">
	<!-- Custom styles for this template -->
    <link href="../css/style.css" rel="stylesheet">
    <link href="../plugin/highlight/styles/github.css" rel="stylesheet">
	
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>
	<!-- Fixed navbar -->
    <nav class="navbar navbar-info navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
        <div class="navbar-logo">
          	<a class="navbar-brand" href="./index.html"><img src="../img/logo.png"/></a>
          	<a class="navbar-brand" href="./index.html">Blade</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">首页</a></li>
            <li class="dropdown active">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档 <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="./index.html">开发者指南</a></li>
                <li><a href="../apidocs/index.html">API参考</a></li>
                <li><a href="../blade-example.html">Blade示例</a></li>
                <li><a href="#">语言规范</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">工具 <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="#">下载&nbsp;Blade</a></li>
                <li role="separator" class="divider"></li>
                <li><a href="#">Eclipse</a></li>
                <li><a href="#">工具FAQ</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">资源 <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="#">示例代码</a></li>
                <li><a href="#">性能</a></li>
                <li role="separator" class="divider"></li>
                <li><a href="#">Blade 短视频</a></li>
              </ul>
            </li>
            <li><a href="#contact">支持</a></li>
            
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="#">微博</a></li>
            <li><a href="#">官方Q群</a></li>
            <li><a href="javascript:void(0)">置顶<span class="sr-only">(current)</span></a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
	
	<div class="container-page docs">
		  <div class="container">
		    <div class="container col-md-10 col-md-offset-1 sub-page">
		      <div class="has-permalinks">
		      <div class="col-md-4">
				  <div class="bs-docs-sidebar hidden-print affix-top" role="complementary">
					<ol class="toc nav bs-sidenav" id="markdown-toc">
					  <li><a href="#section-1">开始</a></li>
					  <li><a href="#section-install">安装Blade</a>
					  	<ol class="nav subnav">
					      <li><a href="#section-withmaven">使用maven</a></li>
					      <li><a href="#section-nomaven">不使用maven</a>    
					    </ol>
					  </li>
					  <li><a href="#section-quickstart">快速入门</a>
					  	<ol class="nav subnav">
					      <li><a href="#section-newpro">新建项目</a></li>
					      <li><a href="#section-configxml">配置web.xml</a></li>
					      <li><a href="#section-configroute">配置路由</a></li>
					      <li><a href="#section-controller">控制器运行机制</a></li>
					      <li><a href="#section-codeview">视图编写</a></li>
					      <li><a href="#section-staticfile">静态文件处理</a></li>
					    </ol>
					  </li>
					  
					  <li><a href="#section-mvc">MVC架构</a>
					  	<li><a href="#section-controllerdesign">controller设计</a>
						  	<ol class="nav subnav">
						      <li><a href="#section-route">路由设置</a></li>
						      <li><a href="#section-interceptor">拦截器设置</a></li>
						      <li><a href="#section-requestdata">请求数据处理</a></li>
						      <li><a href="#section-session">session控制</a></li>
						      <li><a href="#section-outdata">多种数据输出</a></li>
						      <li><a href="#section-log">日志处理</a></li>
						    </ol>
						  </li>
						  <li class="subnav"><a href="#section-modeldesign">model设计</a>
						  	<ol class="nav subnav">
						      <li><a href="#section-modeloverview">概述</a></li>
						      <li><a href="#section-configsql2o">配置blade-sql2o</a></li>
						      <li><a href="#section-crud">CRUD使用</a></li>
						      <li><a href="#section-advanced">高级查询</a></li>
						      <li><a href="#section-transaction">事务处理</a></li>
						    </ol>
						  </li>
						  <li class="subnav"><a href="#section-viewdesign">view设计</a></li>
					  </li>
					  
					</ol>
				  </div>
				</div>
				
				<div class="col-md-8">
					<h1 id="section">开发者指南</h1>
					<p>Blade开发指南告诉你一些能够帮助你创建、测试和部署 Dart 代码的文档、文章和其他开发资源。</p>
					<h2 id="section-1">开始</h2>
					<p>阅读下面内容，或者开始<a href="/#get-started">下载 Dart</a>并玩玩 Dart 编辑器。</p>
				  	<p><a href="/codelabs/darrrt/">海盗们 停下来：编写个 Web 应用吧</a>
					：一步一步创建一个 web 应用 。
					这个一小时代码实验室假设你具有其他编程语言背景，
					但是并不要求对 Blade 或者 HTML 有所了解。
					</p>
				  	<p>
				  		<a href="/docs/dart-up-and-running/contents/ch02.html">框架概览 (<em>Dart: Up and Running</em>, Chapter 2)</a>
				： 介绍 Blade框架 语言中的每个主要功能特性，
				从变量到操作符、从类到库。</p>
				
				  <p><a href="/docs/tutorials/">Blade 教程</a>
				：使用 Blade 创建 web 应用的手把手教程。</p>
				  <h2 id="section-install">安装blade</h2>
				  <p>
				  	<h3 id="section-withmaven">添加依赖</h3>
				  	<p>添加依赖到项目中非常简单，只要确保你的版本是最新的。 
				  		mvnrepository是<a target="_blank" href="https://github.com/biezhi/blade/blob/master/LAST_VERSION.md">最新稳定版本</a>
				  		下面是一个样本：
		  		<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.bladejava&lt;/groupId&gt;
    &lt;artifactId&gt;blade-core&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
					这里添加了blade的核心库，根据你的需求可以添加其他依赖。 比如模版引擎的依赖、数据库操作的依赖等。
				  	</p>
				  	<h3 id="section-nomaven">不使用maven</h3>
				  	<p>
				  		有些同学可能还不会使用maven构建项目，建议有时间的话学习一下。
						不使用maven构建基于blade的项目也非常简单，只要把你需要的jar包加进去就可以了。
						blade核心库文件有2个：
						<ul>
							<li><a href="#">blade-kit.jar</a></li>
							<li><a href="#">blade-core.jar</a></li>
						</ul>
						升级只需更换响应的jar包即可。
				  	</p>
					
					<h2 id="section-quickstart">快速入门</h2>
					<p>
						<code class="java">blade</code>是一个能够进行快速开发应用的框架，快速入门将带领你快速的建立一个<code class="java">blade</code>的项目，然后运行起来。
						接着修改代码，让我们了解整个MVC的运行机制。那么让我们开始创建项目吧！
						这里给大家理一下流程和后续你要做的：
						<ol>
							<li>以maven or 普通方式引入blade的jar包</li>
							<li>配置web.xml并建立包和App.java文件</li>
							<li>编写App.java需要的基础环境</li>
							<li>编写路由和逻辑代码</li>
						</ol>
					</p>
					<h3 id="section-newpro">新建项目</h3>
					<p>
						这里我使用的是eclipse开发工具，如果你使用其他的IDE思路也是大致
						<h4>maven方式 创建一个maven工程 </h4>
						<p>
							<img src="http://i3.tietuku.com/dd94075137057b69.png" /><br /><br />
							<img src="http://i3.tietuku.com/d213c360dc1908e2.png" /><br /><br />
							接下来输入你的groupId、ArtifactId的信息<br /><br />
							<img src="http://i3.tietuku.com/a0fa3133f9299afc.png" /><br /><br />
							这样maven工程就创建OK了，然后我们加入blade的依赖。
							在<code>pom.xml</code>的<code>dependencies</code>中加入
					<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.bladejava&lt;/groupId&gt;
    &lt;artifactId&gt;blade-core&lt;/artifactId&gt;
    &lt;version&gt;最新版本&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
						</p>
						<h4>普通方式创建工程</h4>
						<p>
							创建一个<code>Dynamic Web Project</code>然后加入<code>blade-kit.jar</code>和<code>blade-core.jar</code>即可。
						</p>
					</p>
					<h3 id="section-configxml">配置web.xml</h3>
					<p>
						创建好项目之后配置<code>web.xml</code>，非常简单，加入下面的配置即可
						<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;BladeFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;blade.BladeFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;applicationClass&lt;/param-name&gt;
        &lt;param-value&gt;blade.hello.App&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;BladeFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
						这里的<code class="java">blade.hello.App</code>是你的应用启动类
					</p>
					<h3 id="section-configroute">配置路由</h3>
					<p>
						<pre><code class="java">public class App extends BladeApplication{
    @Override
    public void init() {
        Blade.regRoute("/", IndexController.class, "index");
        Blade.regRoute("/hi", IndexController.class, "hi");
    }
}</code></pre>
						嗯，就这么简单，在应用启动类里配置2个路由，执行方法在<code>IndexRoute</code>类中的<code>index</code>方法和<code>hi</code>方法。
					</p>
					<h3 id="section-controller">控制器运行机制</h3>
					<p>
						<pre><code class="java">// 路由
public class IndexController {

    // 返回首页界面
    public String index(){
        return "index";
    }	
    // hi请求
    public void hi(Request request){
        System.out.println("进入hello!");
	System.out.println(request.query("name"));
    }
}</code></pre>
						这个就是控制器类，里面定义了2个请求方法，<code>index</code>方法返回视图为<code>index.jsp</code>的页面。
						<code>hi</code>方法接收到请求，可以在url上传递参数name。
						`blade`默认的视图路径是<code>/WEB-INF/</code>，那么<code>index</code>方法中返回视图默认会去<code>WEB-INF</code>下找<code>index.jsp</code>。
						当然这一切都是好商量的，详细请看[路由配置](#)
					</p>
					<h3 id="section-codeview">视图编写</h3>
					<p>
						<code>blade</code>默认支持JSP方式渲染视图，也支持很多模板引擎，所以写视图就和以前怎么写JSP是一样的。
					</p>
					<h3 id="section-staticfile">静态文件处理</h3>
					<P>
						当我们的应用中存在图片、JS、CSS等文件不需要被框架处理的时候，应该做一个配置。
						<p><code>Blade.staticFolder("/static/", "/upload/");</code></p>
						这里是<code>/</code>是<code>webapp</code>的根目录。
						
						<b>这里有一个最基本的入门项目 <a href="https://github.com/bladejava/hello" target="_blank">hello</a> ，你可以学习它！</b>
					</P>
					
					
					<h2 id="section-mvc">MVC架构</h2>
					<p>
						<code>blade</code>是一个典型的MVC框架，它的执行逻辑如下：<br /><br />
						<img src="http://i3.tietuku.com/91bd5d917812f23d.png"><br /><br />
						通过文字来描述如下：
						<ol>
							<li>用户在浏览器发送一个请求，首先由<code>BladeFilter</code>接收然后交给<code>RequestHandler</code>处理。</li>
							<li>如果是静态文件(这里我们有配置什么是静态文件范围)交给web容器处理，否则继续向下走</li>
							<li>执行<code>before</code>拦截，如果你配置了<code>before</code>拦截器那么它会先执行</li>
							<li>查找路由对应的方法，找到后初始化<code>BladeContext</code>对象并执行路由方法</li>
							<li>执行<code>after</code>拦截器</li>
							<li>返回视图或者其他操作</li>
						</ol>
							
						<p><strong>参数配置</strong></p>
						<code>blade</code>目前支持Java代码、properties、JSON方式进行配置，很简单的应用直接编码即可，
						一般部署在外网上用配置文件方便一些，用户可以通过简单的配置就可以获得很大的灵活性。
						
						<p><strong>系统默认参数</strong></p>
						为了提高开发速度，<code>blade</code>框架内置了一些默认的配置
						<ul>
							<li>视图文件位置=/WEB-INF/</li>
							<li>默认渲染引擎=JSP</li>
							<li>默认视图文件后缀=.jsp</li>
							<li>默认文件编码=UTF-8</li>
							<li>默认开启DEBUG模式</li>
							<li>默认不开启数据库缓存</li>
						</ul>
						获取配置参数的方法<code>Blade.config().get(key)</code>
					</p>
					<h3 id="section-controllerdesign">controller设计</h3>
						<h4 id="section-route">路由设置</h4>
						什么是路由设置呢？
						前面介绍的MVC结构执行时，<code>blade</code>存在三种方式的路由:注解路由、函数式路由、接口回调路由，接下来详细的讲解如何使用这三种路由。
						<dl>
							<dt>注解路由</dt>
							<dd>
								这种写法可能是大家最习惯的，也是常见的写法之一，用注解配置一个路由
								<pre><code class="java">@Path("/")
public class Hello {
	
	@Route("hello")
	public String hello() {
		System.out.println("hello");
		return "hello.jsp";
	}
		
	@Route(value = "post", method = HttpMethod.POST)
	public void post(Request request) {
		String name = request.query("name");
		System.out.println("name = " + name);
	}
	
	@Route("users/:name")
	public ModelAndView users(Request request, Response response) {
		System.out.println("users");
		String name = request.pathParam(":name");
		
		ModelAndView modelAndView = new ModelAndView("users");
		modelAndView.add("name", name);
		return modelAndView;
	}

	@Route("index")
	public String index(Request request) {
		request.attribute("name", "jack");
		return "index.jsp";
	}
}</code></pre>
							<p><strong>@Path是什么？</strong></p>
							<ul>
								<li>每一个路由的类必须用<code>@Path</code>标识，这样路由解析器知道这是一个路由类</li>
								<li><code>@Path</code>注解只有一个value参数配置，相当于<code>namespace</code></li>
							</ul>
							
							<p><strong>@Route是什么？</strong></p>
							<ul>
								<li><code>Route</code>是一个路由的最小单元，用于方法上</li>
								<li><code>Route</code>的参数有<code>value</code>，<code>method</code>，<code>acceptType</code></li>
								<li><code>value</code>用于配置路由的URL，也就是http请求的路径</li>
								<li>一般不以<code>/</code>开头，因为<code>@Path</code>上会指定的，写法如下：
								<ul>
									<li>/hello</li>
									<li>/user/hello</li>
									<li>/user/:uid</li>
									<li>/user/:uid/post</li>
								</ul></li>
								<li>Rest风格的路由配置，一定适合你的口味！</li>
							</ul>
							</dd>
						</dl>
						
						<dl>
							<dt>函数式路由</dt>
							<dd>
								函数式路由用起来真的很酷
								<pre><code class="java">Blade.regRoute("/", IndexRoute.class, "index");
Blade.regRoute("/hi", IndexRoute.class, "hi");
Blade.regRoute("/signin", IndexRoute.class, "post:signin");
Blade.regRoute("/delete", IndexRoute.class, "delete", HttpMethod.DELETE);</code></pre>
								
								配置路由的方式很简单，下面看看对应的`IndexRoute`类
								<pre><code class="java">// 路由
public class IndexRoute {

	// 返回首页界面
	public String index(){
		return "index";
	}
	
	// hi请求
	public void hi(Request request, Response response){
		System.out.println("进入hello!");
		System.out.println(request.query("name"));
	}

        // signin请求
	public void signin(Request request, Response response){
		System.out.println("进入signin!");
	}

        // delete请求
	public void delete(Request request, Response response){
		System.out.println("进入delete!");
	}
}</code></pre>
							</dd>
						</dl>
						
						<dl>
							<dt>回调式路由</dt>
							<dd>
								从blade1.6版本开始支持了基本的RESTful函数式路由。最简单的blade路由由URI和闭包函数组成，如果你使用Java8那就再爽不过了。
								
								<p><strong>基本GET路由</strong></p>
								<pre><code class="java">Blade.get("/", new Handler(){
  public String run(Request req, Response res){
    //do some
  }
});</code></pre>
								
								<p><strong>基本POST路由</strong></p>
								<pre><code class="java">Blade.post("/signin", new Handler(){
  public String run(Request req, Response res){
    //do some
  }
});</code></pre>
								
								<p><strong>注册一个可以响应任何HTTP的路由</strong></p>
								<pre><code class="java">Blade.all("/hello", new Handler(){
  public String run(Request req, Response res){
    //do some
  }
});</code></pre>
								
								<p><strong>所有的支持的基础函数如下所示</strong></p>
								<pre><code class="java">Blade.get(path, CallBack);
Blade.post(path, CallBack);
Blade.delete(path, CallBack);
Blade.put(path, CallBack);
Blade.patch(path, CallBack);
Blade.head(path, CallBack);
Blade.trace(path, CallBack);
Blade.options(path, CallBack);
Blade.connect(path, CallBack);
Blade.all(path, CallBack);</code></pre>

								<p><strong>如何操作请求和响应</strong></p>
								<ul>
									<li>在路由方法上你可以定义Request和Response参数由框架自动注入</li>
									<li>Request处理请求，对HttpServletRequest进行了封装</li>
									<li>Response处理响应，对HttpServletResponse进行了封装</li>
								</ul>
								
								<p><strong>Route的其他概念</strong></p>
								对于<code>POST</code>,<code>GET</code>,<code>DELETE</code>等请求的配置就用到`method`了，
								使用非常简单：
								<p><code>@Route(value = "/post", method = HttpMethod.POST)</code></p>
								嗯 没错 就是这么easy！！

								下面是<code>acceptType</code>，这个一般用不到，如果你限制请求类型的话配置一下即可，
								以前的做法就是用HttpServletRequest对象控制。
								
								<p><strong>如何输出到页面？</strong></p>
								想到大家应该比较关心这个了，<code>blade</code>框架内置了JSP渲染，
								所以你看到的<code>return "hello.jsp"</code>代码是可以返回到<code>hello.jsp</code>文件上的。
								当然<code>blade</code>还支持类似spring的<code>ModelAndView</code>，怎么使用呢，
								<pre><code class="java">@Route("model")
public void model() {
    return new ModelAndView("model.jsp");
}</code></pre>
								
								喏，很简单吧。什么意思呢？
								<code>ModelAndView</code>是一个视图模型对象，在spring里出现，里面也就是存放视图和数据而已，
								你可以看它的源码，用<code>Map</code>存放数据，<code>String</code>变量存放视图文件。
								
								应该没有花你多长时间，看来接受<code>blade</code>是非常快速的！
							</dd>
							
						</dl>
						
						<h4 id="section-interceptor">拦截器设置</h4>
						<p>
							拦截器在Spring中是一个惯用的编程手段，在<code>blade</code>中也存在拦截器，功能简化一些。
							<pre><code class="java">@Interceptor
public class BaseInterceptor {
	
	TimwMonitor monitor = TimwManager.getTimerMonitor();
	
	@Before("/*")
	public void before(Request request, Response response){
		
		System.out.println("before...");
		monitor.start();
		
		request.attribute("base", request.contextPath());
		request.attribute("static_v", "20150722");
		
		User login_user = request.session().attribute(Constant.LOGIN_SESSION);
	}
	
	@After("/*")
	public void after(){
		System.out.println("after...");
		monitor.end();
		monitor.render();
		monitor.renderAvg();
	}
}</code></pre>
							在<code>1.2.6</code>版本之后支持函数式注册拦截器，写法如下：
							<pre><code class="java">// 注册拦截器
Blade.regInterceptor("/*", Interceptor.class, "before");
```
拦截器类
```java
public class Interceptor {

	public void before(Request request, Response response){
		System.out.println("before...");
		
		request.attribute("base", request.contextPath());
		request.attribute("static_v", "20150722");
		
		User login_user = request.session().attribute(Constant.LOGIN_SESSION);
	}
}</code></pre>
						</p>
						
						<h4 id="section-requestdata">请求数据处理</h4>
						<p>
							<h3>获取参数</h3>
							<p>我们经常需要获取用户传递的数据，包括Get、POST等方式的请求，blade里面会自动解析这些数据，你可以通过如下方式获取数据：</p>
							使用Request对象的方法
							<pre><code class="java">request.query("");
request.queryToInt("");
request.queryToDouble("");
request.queryToFloat("");
request.queryToBoolean("");
request.queryToLong("");</code></pre>
							使用例子如下：
							<pre><code class="java">// hi请求
public void hi(Request request){
    System.out.println(request.query("name"));
}</code></pre>
							更多其他的<code>request</code>的信息，用户可以通过<code>request</code>获取信息，关于该对象的属性和方法参考手册<a href="">Request</a>。

							<h3>获取path上的参数</h3>
							在REST风格的URL路径上，我们的配置是类似于<code>/user/:uid</code>酱紫的。
							那么如何获取呢？blade的request对象提供了如下方法，使用很简单
							<pre><code class="java">request.pathParam("");
request.pathParamToInt("");
request.pathParamToLong("");</code></pre>
								
							<h3>获取 Request Body 里的内容</h3>
							在 开发API的时候，我们经常会用到<code>JSON</code>或<code>XML</code>来作为数据交互的格式，
							如何在<code>blade</code>中获取<code>Request Body</code>里的<code>JSON</code>或<code>XML</code>的数据呢？
							<pre><code class="java">String body = request.body();</code></pre>
							
							<h3>文件上传</h3>
							<p>
								blade默认支持对表单文件上传的解析，就是别忘记在你的<code>form</code>表单中增加这个属性<code>enctype="multipart/form-data"</code>，否则你的浏览器不会传输你的上传文件。
								文件上传之后一般是放在系统的内存里面，如果文件的<code>size</code>大于设置的缓存内存大小，
								那么就放在临时文件中，默认的缓存内存是<code>1MB</code>，你可以通过如下来调整这个缓存内存大小:
								<pre><code class="java">ServletFileUpload fileUpload = ServletFileUpload.parseRequest(request.servletRequest());
// 判断是否是表单上传类型
boolean isMultipart = fileUpload.isMultipartContent(request.servletRequest());
if(isMultipart){
    // 10MB
    int buf_size = 10 * 1024 * 1024;
    fileUpload.setBufferSize(buf_size);
}</code></pre>
								<code>blade</code>提供获取表单上传文件的方法<code>FileItem fileItem = fileUpload.fileItem("上传Input的name");</code>
								下面是一个上传文件的示例：
								<pre><code class="java">/**
 * 上传图片
 */
@Route(value="uploadimg", method = HttpMethod.POST)
public void uploadImg(Request request, Response response){
    ServletFileUpload fileUpload = 
       ServletFileUpload.parseRequest(request.servletRequest());
    boolean isMultipart = fileUpload.isMultipartContent(request.servletRequest());
    if(isMultipart){
        FileItem fileItem = fileUpload.fileItem("image");
        String suffix = FileKit.getExtension(fileItem.getFileName());
            if(StringKit.isNotBlank(suffix)){
                suffix = "." + suffix;
            }
			
            String saveName = DateKit.dateFormat(new Date(), "yyyyMMddHHmmssSSS") 
                       + "_" + StringKit.getRandomChar(10) + suffix;
	    String fname = Blade.webRoot() + File.separator + 
                       Constant.UPLOAD_FOLDER + File.separator + saveName;
            File file = new File(fname );
			
            IOKit.write(fileItem.getFileContent(), file);
			
            JSONObject jsonObject = new JSONObject();
			
            if(file.exists()){
				
                String prfix = request.url().replaceFirst(request.servletPath(), "/");
                String filePath = Constant.UPLOAD_FOLDER + "/" + saveName;
                String url = prfix + filePath;
				
                jsonObject.put("id", saveName);
                jsonObject.put("url", url);
                jsonObject.put("success", 1);
                jsonObject.put("message", "上传成功");
				
            } else {
                jsonObject.put("success", 0);
                jsonObject.put("message", "上传失败");
            }	
            response.json(jsonObject.toString());
        }
}</code></pre>
							</p>
						</p>
						
						<h4 id="section-session">session控制</h4>
						<p>
							绝大部分的用户系统都会用到`session`来保存用户登录状态，在`blade`中使用起来极为方便。
							<pre><code class="java">User user = userService.login(login_name, pass_word);
if(null != user){
    request.session().attribute(Constant.LOGIN_SESSION, user);
} else {
    modelAndView.add(this.ERROR, "用户名或密码错误");
}</code></pre>
							
							这个代码片段是用户登录后将用户对象存在<code>session</code>中。
							<pre><code class="java">User login_user = request.session().attribute(Constant.LOGIN_SESSION);
// 未登录
if(null == login_user && request.uri().indexOf("/admin") != -1){
    response.redirect("/signin");
    return;
}</code></pre>
							拦截器中获取用户对象，如果session中没有则跳转到登录页。
							
						</p>
						
						<h4 id="section-outdata">多种数据输出</h4>
						<p>
							按照数据输出我们有这么几种，以前是把数据放在<code>request</code>域中的，
							后面流行的<code>JSON</code>数据、<code>XML</code>数据等格式返回。
							<code>blade</code>设计之初考虑了<code>API</code>功能的开发，<code>Response</code>对象提供了这样的方式直接输出：
							
							<p><strong>将数据存在Request域返回</strong></p>
							<pre><code class="java">public String index(Request request){
    request.attribute("name", "jack");
    return "index";
}</code></pre>
							<p><strong>JSON方式返回</strong></p>							
							<pre><code class="java">public void getUser(Response response){
	JSONObject data = new JSONObject();
	data.put("status", 200);
	data.put("data", Map / List);
	
	response.json(data.toString());
}</code></pre>
							<code>blade</code>提供了对<code>JSON</code>的处理工具类<code>JSONKit</code>
							
							<p><strong>XML方式返回</strong></p>
							<pre><code class="java">public void getUser(Response response){
    String xml = "xml内容";
    response.xml(xml);
}</code></pre>
							
							<code>blade</code>后期会考虑直接将对象转为<code>xml</code>数据格式，当前版本还不支持。
							
						</p>
						<h4 id="section-log">日志处理</h4>
						<p>
							<code>blade</code>中内置了日志模块，当然可以满足简单的开发需求，也扩展了<code>Log4j</code>的适配。
							<pre><code class="java">Logger logger = Logger.getLogger(LogTest.class);
logger.info("hello %s", "jack");</code></pre>

							其他语法都类似与`log4j`这里不详细介绍了。
						</p>
						
					<h3 id="section-modeldesign">model设计</h3>
						<h4 id="section-modeloverview">概述</h4>
						<p>
							blade-sql2o是一款基于sql2o来更快速的操作数据库的框架。
							<p><strong>特性</strong></p>
							<ul>
								<li>支持大部分Java数据类型</li>
								<li>轻松上手，采用简单的 CRUD 风格</li>
								<li>支持链式操作</li>
								<li>支持面向对象语法</li>
								<li>允许直接使用 SQL 查询／映射</li>
							</ul>
						</p>
						<h4 id="section-configsql2o">配置blade-sql2o</h4>
						<p>
							首先加入`blade-sql2o`组件
							<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.bladejava&lt;/groupId&gt;
    &lt;artifactId&gt;blade-sql2o&lt;/artifactId&gt;
    &lt;version&gt;最新版本&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
							
							然后配置数据库
							<p><strong>编码方式</strong></p>
							<pre><code class="java">Sql2oPlugin sql2oPlugin = Sql2oPlugin.INSTANCE;
sql2oPlugin.config("jdbc:mysql://127.0.0.1:3306/test", "com.mysql.jdbc.Driver", "user", "pass");
sql2oPlugin.run();</code></pre>
							
							<p><strong>配置文件方式</strong></p>
							<pre><code class="java">// 配置数据库插件
Sql2oPlugin.INSTANCE.autoConfig().run();</code></pre>

							配置文件中
							<pre><code class="bash">blade.dburl=jdbc:mysql://127.0.0.1:3306/test
blade.dbdriver=com.mysql.jdbc.Driver
blade.dbuser=root
blade.dbpass=root</code></pre>
							
							这样数据库配置就完成了，接下来带你写一个<code>Model</code>
							<pre><code class="java">
@Table(value="t_user", PK = "uid")
public class User implements Serializable{

	private static final long serialVersionUID = -7718091985540738974L;
	
	private Integer uid;
	
	private String loginname;

	private String password;
	
	private String mail;
	
	public User() {
	}

	public Integer getUid() {
		return uid;
	}

	public void setUid(Integer uid) {
		this.uid = uid;
	}

	public String getLoginname() {
		return loginname;
	}

	public void setLoginname(String loginname) {
		this.loginname = loginname;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getMail() {
		return mail;
	}

	public void setMail(String mail) {
		this.mail = mail;
	}
}</code></pre>
							这里我们定义了一个<code>User</code>类，实现<code>Serializable</code>接口。
							那么这个注解是什么意思呢？
							<code>@Table</code>用于配置这个model对应数据库的表和主键是什么，如果不填写<code>PK</code>则默认为<code>id</code>
							这样就配置好一个基础的model了，下面看看如何使用吧！
						</p>
						<h4 id="section-crud">CRUD使用</h4>
						<p>
							一般在java中我们会分为Controller、Service、Dao层，当然并不是所有人都这么划分，
							在blade中依然保持Service层的存在，让Service单独去处理业务逻辑，我不怎么看好很多人把业务写在Model中。
							下面的示例展示了<code>blade-sql2o</code>最基础的的CRUD
							
							<pre><code class="java">@Component
public class UserServiceImpl implements UserService {
    private Model<User > model = new Model<User>(User.class);
    //根据主键查询User对象，对 就这么一行代码！
    public User getUserByUid(Integer uid){
        return model.fetchByPk(uid);
    }
    //根据登录名进行模糊查询
    public List<User> getUser(String login_name){
        return model.select().like("login_name", "%" + login_name).fetchList();
    }
    //根据uid修改email
    public boolean update(Integer uid, String email){
        return model.update().param("email", email).where("uid", uid).executeAndCommit() > 0;
    }
    //根据uid删除user
    public boolean delete(Integer uid){
        return model.delete().where("uid", uid).executeAndCommit() > 0;
    }
    //插入一条User
    @Override
    public boolean save(String login_name, String email) {
	return model.insert()
	.param("login_name", login_name)
	.param("email", email).executeAndCommit() > 0;	
    }
}</code></pre>
							看起来是不是很爽，大部分操作只要一行代码！！
							
						</p>
						
						<h4 id="section-advanced">高级查询</h4>
						<p>
							<p><strong>分页查询</strong></p>
							<pre><code class="java">Page<Post> page = model.select()
.like("title", "%" + title + "%")
.where("`type`", type)
.where("`status`", status)
.orderBy(orderBy)
.fetchPage(pageIndex, pageSize);</code></pre>

							<p><strong>查询记录数</strong></p>
							<pre><code class="java">public Long getUserCount(String email){
    return model.count().where("email", email).fetchCount();
}</code></pre>

							<p><strong>关联查询</strong></p>
							<pre><code class="java">List<User> userList = model.select("select t1.* from t_user t1 inner join t_relation t2 on t1.uid=t2.uid")
		.where("t2.friend_uid", uid).where("t2.status", 0).fetchList();</code></pre>
		
						</p>
						
						<h4 id="section-transaction">事务处理</h4>
						<p>
							有些时候我们会用到事务处理，比如要删除2条数据，必须通知删除成功。
							下面是一个例子：
							<pre><code class="java">@Override
public boolean delete(String pids) {
    Connection connection = model.getSql2o().beginTransaction();
    try {
        // 删除一个post
        connection = model.update().param("status", "delete").where("pid", pid).execute(connection);
        // 删除关联
        connection = model.delete("delete from t_relation").where("pid", pid).execute(connection);
        connection.commit();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        if(null != connection){
            connection.rollback();
        }
    }
    return false;	
}</code></pre>
						</p>
						
					<h3 id="section-viewdesign">view设计</h3>
					<p>
						<p><code>blade</code>默认采用的是JSP引擎进行处理，同时支持<code>velocity</code>、<code>beetl</code>、<code>jetbrick</code>模板引擎。</p>
						
						<p><strong>模板目录</strong></p>
						
						默认所有视图文件存放在<code>webapp</code>下的<code>WEB-INF</code>文件夹下，你可以进行设置：
						<pre><code class="java">Blade.viewPrefix("/WEB-INF/views/");</code></pre>
						
						<p><strong>模板数据</strong></p>
						
						<p><code>blade</code>支持2种方式进行数据存储</p>
						<pre><code class="java">public String index(Request request){
    request.attribute("name", "jack");
    return "index";
}
						
public ModelAndView index(Request request){
    ModelAndView modelAndView = new ModelAndView("index");
    modelAndView.add("name", "jack");
    return modelAndView;
}</code></pre>
						
												
					</p>
				</div>
		
		      </div>
		    </div>
		  </div>
	</div>

	  <footer class="footer container-full">
	    <div class="container">
	      <div class="row">
	        <div class="col-md-5">
	          <h3>一个用于快速高效开发web 应用程序的框架</h3>
	          <p>Blade 是一个 <a href="https://github.com/biezhi/blade">开源项目</a>，由  <a href="http://my.oschina.net/biezhi" target="_blank">biezhi</a> 编写。</p>
	          <p class="sm">除非注明，该页面内容使用 the Creative Commons Attribution 3.0 License 发布，示例代码使用  BSD License 发布。</p>
	        </div>
	        <div class="col-md-2 col-md-offset-1">
	          <h4>受欢迎的文章</h4>
	          <ul>
	          	<li><a href="#">blade音乐系统搭建</a></li>
	          	<li><a href="#">java-china发起者</a></li>
	            <li><a href="#">性能</a></li>
	          </ul>
	        </div>
	        <div class="col-md-2">
	          <h4>资源</h4>
	          <ul>
	            <li><a href="http://pub.dartlang.org/">Eclipse下载</a></li>
	            <li><a href="https://github.com/biezhi/blade/issues">Blade bugs and feature requests</a></li>
	          </ul>
	        </div>
	        <div class="col-md-2">
	          <h4>社区</h4>
	          <ul>
	            <li><a href="#">邮件列表</a></li>
	            <li><a href="#">中文社区</a></li>
	            <li><a href="http://weibo.com/u/5238733773">中文微博</a></li>
	            <li><a href="http://stackoverflow.com/questions/tagged/blade">Stack Overflow</a></li>
	          </ul>
	        </div>
	      </div>
	    </div>
	  </footer> <!-- End footer -->
	   
	   <a href="https://github.com/biezhi/blade">  
		<img style="position: absolute; top: 0; right: 0; border: 0;" 
		    src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" 
		    alt="Fork me on GitHub" 
		    data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png">
		</a>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>
    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>
	<script src="../js/ripples.min.js"></script>
    <script src="../js/material.min.js"></script>
    <script src="../plugin/highlight/highlight.pack.js"></script>
    <script>
        $(document).ready(function() {
            // This command is used to initialize some elements and make them work properly
            $.material.init();
            hljs.initHighlightingOnLoad();
        });
    </script>
</body>

</html>
